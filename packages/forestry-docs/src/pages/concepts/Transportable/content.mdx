import {SeeMore} from "../../../components/SeeMore";

Because Forestry states are class instances they are transportable: they can be
instantiated for individual components, or kept globally as resources that can
be subscribed to by any component that needs access to their data or methods.

They can be used in React Native, and can also be used in "not React" -- Angular, Vue or general purpose Javascript applications, or web workers.

In fact they are not at all dependent on Browser context 
and can be used in a server.

## Aren't classes evil?

No they are not. relying on deep inheritance and over reliance on intelligent properties may be
unhealthy but as a cluster of behaviors and methods with a known ecosystem of values is not an
inherently unhealthy pattern.

<SeeMore title="A more Detailed Breakdown">
The Functional Programming pattern has problems with classes because of:

1. polymoprhism - depending on functions to "intelligently" work based on inherited behavior
2. immutability - values change in the referential tree without management
3. inheritance  - related to polymorphism, wierd "triangles" of multiple parent behaviors
4. purity/side effects

Forest's classes have very little inheritance and no overloading of methods. If you don't overload
methods, and essentially "add new batches of behavior" without overlap, you don't expose yourself
to inheritance and polymorphism.

Immutability and purity are solved by using [RxJS](https://rxjs.dev/guide/overview), a functional processing system, to manage
communication and stateful-ness. The objects in Forest are largely used to keep a journal of past
state in a stack and allow synchronous transactions and rollbacks. One of the problems with
functional patterns is it assumes there is never a scenario where you may want to "partly expose"
values, test them, and then commit them - you can't manage state in time like that if you don't
have an infrastructure that understands data and time.


Plenty of healthy systems rely on classes including RxDB, Firebase, Scala, C#,
Mapbox, Pixi, Three.js, and many, many more. Functional design is a good architecture, but it does
not always deliver everything that every use case demands. And the existence of a useful
architectural pattern doesn't eliminate the utility of other patterns of engineering.

</SeeMore>
## Testing Trees

Trees can be tested absent of their view to validate business concepts.
This is 1000% more efficient than mocking up and simulting user interactions
in a headless view scenario. Changes to business values operate in their own
sphere, and shouldn't be dependent on the view that expresses their state
out to the DOM.

<SeeMore title="Show a Unit Test">
Here is the unit test suite for the Eggs example from [Transactional](/contents/transactional):
Collections have a similar profile and testing pattern.

```JavaScript

type Egg = {
  id: string;
  daysLeft: number;
};
describe('concepts', () => {
  describe('transactional', () => {
    it('should rollback collections', () => {
      const f = new Forest();

      type Egg = {
        id: string;
        daysLeft: number;
      };

      const EXPIRED_MSG = 'Egg has expired';
      const eggValidator = (e: Egg) => {
        if (e.daysLeft <= 0) {
          throw new Error(EXPIRED_MSG);
        }
      };
      const eggsValidator = (es: Egg[]) => {
        for (const e of es) {
          eggValidator(e);
        }
      };

      const INITIAL = [
        { id: 'alpha', daysLeft: 4 },
        { id: 'beta', daysLeft: 3 },
        { id: 'gamma', daysLeft: 2 },
      ];

      const LESS_ONE_DAY = [
        { id: 'alpha', daysLeft: 3 },
        { id: 'beta', daysLeft: 2 },
        { id: 'gamma', daysLeft: 1 },
      ];

      const eggs = new Collection<Egg[]>(
        'eggs',
        {
          initial: INITIAL,
          validator: eggsValidator,
          actions: {
            removeADay(coll: CollectionIF<Egg[]>) {
              for (const egg of coll.value) {
                coll.act('removeEggDay', egg.id);
              }
            },
            removeEggDay(coll: CollectionIF<Egg[]>, id: string) {
              const eggs: Egg[] = coll.value.map((egg) => {
                if (egg.id === id) {
                  return { ...egg, daysLeft: egg.daysLeft - 1 };
                }
                return egg;
              });
              coll.next(eggs);
            },
            removeEgg(coll: CollectionIF<Egg[]>, id: string) {
              coll.mutate(({ value }) => {
                const out = value.filter((egg: Egg) => egg.id !== id);
                return out;
              }, 'removing egg ' + id);
            },
            removeADayWithCatch(coll: CollectionIF<Egg[]>) {
              for (const egg of coll.value) {
                try {
                  coll.act('removeEggDay', egg.id);
                } catch (error) {
                  if (error instanceof Error && error.message === EXPIRED_MSG) {
                    coll.act('removeEgg', egg.id);
                  } else {
                    throw error;
                  }
                }
              }
            },
          },
        },
        f
      );

      expect(eggs.value).toEqual(INITIAL);

      eggs.act('removeADay');

      expect(eggs.value).toEqual(LESS_ONE_DAY);

      expect(() => eggs.act('removeADay')).toThrow();

      expect(eggs.value).toEqual(LESS_ONE_DAY);

      eggs.act('removeADayWithCatch');
      expect(eggs.value).toEqual([
        { id: 'alpha', daysLeft: 2 },
        { id: 'beta', daysLeft: 1 },
      ]);
    });

    it('should observe change', () => {
      const f = new Forest();

      const EXPIRED_MSG = 'Egg has expired';
      const eggValidator = (e: Egg) => {
        if (e.daysLeft <= 0) {
          throw new Error(EXPIRED_MSG);
        }
      };
      const eggsValidator = (es: Egg[]) => {
        for (const e of es) {
          eggValidator(e);
        }
      };

      const INITIAL = [
        { id: 'alpha', daysLeft: 4 },
        { id: 'beta', daysLeft: 3 },
        { id: 'gamma', daysLeft: 2 },
      ];

      const eggsCollection = new Collection<Egg[]>(
        'eggs',
        {
          initial: INITIAL,
          validator: eggsValidator,
          actions: {
            removeADay(coll: CollectionIF<Egg[]>) {
              for (const egg of coll.value) {
                coll.act('removeEggDay', egg.id);
              }
            },
            removeEggDay(coll: CollectionIF<Egg[]>, id: string) {
              const eggs: Egg[] = coll.value.map((egg) => {
                if (egg.id === id) {
                  return { ...egg, daysLeft: egg.daysLeft - 1 };
                }
                return egg;
              });
              coll.next(eggs);
            },
            removeEgg(coll: CollectionIF<Egg[]>, id: string) {
              coll.mutate(({ value }) => {
                const out = value.filter((egg: Egg) => egg.id !== id);
                console.log('out after rmoving', id, 'is', out);
                return out;
              }, 'removing egg ' + id);
            },
            removeADayWithCatch(coll: CollectionIF<Egg[]>) {
              for (const egg of coll.value) {
                try {
                  coll.act('removeEggDay', egg.id);
                } catch (error) {
                  if (error instanceof Error && error.message === EXPIRED_MSG) {
                    coll.act('removeEgg', egg.id);
                  } else {
                    throw error;
                  }
                }
              }
            },
          },
        },
        f
      );

      type EggSummary = Record<string, number>;

      function summary(eggs: Egg[]): EggSummary {
        const out: EggSummary = {};
        for (const egg of eggs) {
          out[egg.id] = egg.daysLeft;
        }
        return out;
      }

      type EggTimer = {
        time: number;
        eggs: EggSummary;
        source: string;
        act: string;
      };
      const log: EggTimer[] = [];

      f.observe('eggs').subscribe((eggs: Egg[]) => {
        log.push({
          eggs: summary(eggs),
          time: f.time,
          source: 'observe',
          act: eggsCollection.tree.top?.cause,
        });
      });

      eggsCollection.tree.subscribe((eggs: Egg[]) => {
        log.push({
          eggs: summary(eggs),
          time: f.time,
          source: 'tree.subscribe',
          act: eggsCollection.tree.top?.cause,
        });
      });

      eggsCollection.act('removeADay');
      eggsCollection.act('removeADayWithCatch');

      expect(log).toEqual([
        {
          eggs: {
            alpha: 4,
            beta: 3,
            gamma: 2,
          },
          time: 1,
          source: 'observe',
          act: 'INITIAL VALUE',
        },
        {
          eggs: {
            alpha: 4,
            beta: 3,
            gamma: 2,
          },
          time: 1,
          source: 'tree.subscribe',
          act: 'INITIAL VALUE',
        },
        {
          eggs: {
            alpha: 3,
            beta: 3,
            gamma: 2,
          },
          time: 5,
          source: 'tree.subscribe',
          act: '(next)',
        },
        {
          eggs: {
            alpha: 3,
            beta: 2,
            gamma: 2,
          },
          time: 8,
          source: 'tree.subscribe',
          act: '(next)',
        },
        {
          eggs: {
            alpha: 3,
            beta: 2,
            gamma: 1,
          },
          time: 11,
          source: 'tree.subscribe',
          act: '(next)',
        },
        {
          eggs: {
            alpha: 3,
            beta: 2,
            gamma: 1,
          },
          time: 11,
          source: 'observe',
          act: '(next)',
        },
        {
          eggs: {
            alpha: 2,
            beta: 2,
            gamma: 1,
          },
          time: 15,
          source: 'tree.subscribe',
          act: '(next)',
        },
        {
          eggs: {
            alpha: 2,
            beta: 1,
            gamma: 1,
          },
          time: 18,
          source: 'tree.subscribe',
          act: '(next)',
        },
        {
          eggs: {
            alpha: 2,
            beta: 1,
            gamma: 1,
          },
          time: 20,
          source: 'observe',
          act: '(next)',
        },
        {
          eggs: {
            alpha: 2,
            beta: 2,
            gamma: 1,
          },
          time: 24,
          source: 'tree.subscribe',
          act: '(next)',
        },
        {
          eggs: {
            alpha: 2,
            beta: 1,
            gamma: 1,
          },
          time: 27,
          source: 'tree.subscribe',
          act: '(next)',
        },
        {
          eggs: {
            alpha: 2,
            beta: 1,
          },
          time: 32,
          source: 'tree.subscribe',
          act: 'removing egg gamma',
        },
        {
          eggs: {
            alpha: 2,
            beta: 1,
          },
          time: 32,
          source: 'observe',
          act: 'removing egg gamma',
        },
      ]);
    });
  });
});
```
</SeeMore>
