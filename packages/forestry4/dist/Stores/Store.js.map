{"version":3,"file":"Store.js","sources":["../../src/Stores/Store.ts"],"sourcesContent":["import {\n  ActionExposedRecord,\n  Listener,\n  StoreIF,\n  StoreParams,\n  ValueTestFn,\n  Path,\n} from '../types';\nimport { BehaviorSubject, Observable, Subscription } from 'rxjs';\nimport { distinctUntilChanged } from 'rxjs/operators';\nimport { isEqual } from 'lodash-es';\nimport asError from '../lib/asError';\nimport { isZodParser, ZodParser } from '../typeguards';\nimport { enableMapSet, produce } from 'immer';\nimport { methodize, testize } from './helpers';\nimport { getPath, setPath } from '../lib/path';\nimport { pathString } from '../lib/combinePaths';\n\n// Enable Immer support for Map and Set\nenableMapSet();\n\nexport class Store<\n  DataType,\n  Actions extends ActionExposedRecord = ActionExposedRecord,\n> implements StoreIF<DataType, Actions>\n{\n  /**\n   * note - for consistency with the types subject is a generic subject;\n   * however internally it is a BehaviorSubject.\n   * @private\n   */\n  #subject?: BehaviorSubject<DataType>;\n  get subject(): Observable<DataType> {\n    return this.#subject;\n  }\n\n  $: Actions;\n\n  get acts(): Actions {\n    return this.$;\n  }\n\n  constructor(p: StoreParams<DataType, Actions>, noSubject = false) {\n    // Store initial value\n    this.initialValue = p.value;\n\n    // Apply prep function to initial value if it exists\n    const processedValue = p.prep ? p.prep({}, p.value, p.value) : p.value;\n\n    if (!noSubject) {\n      this.#subject = new BehaviorSubject(processedValue);\n    }\n    if ('schema' in p && p.schema) {\n      this.schema = p.schema;\n    }\n\n    this.debug = !!p.debug;\n\n    const self = this;\n    this.$ = methodize<DataType, Actions>(p.actions ?? {}, self);\n\n    if (p.tests) {\n      this.tests = testize<DataType>(p.tests, self);\n    }\n\n    if (p.prep) {\n      this.prep = p.prep;\n    }\n\n    if (p.name && typeof p.name === 'string') {\n      this.#name = p.name;\n    }\n    if (p.res && p.res instanceof Map) {\n      p.res.forEach((value, key) => this.res.set(key, value));\n    }\n  }\n\n  public debug: boolean; // more alerts on validation failures;\n  public prep?: (\n    input: Partial<DataType>,\n    current: DataType,\n    initial: DataType,\n  ) => DataType;\n  protected initialValue: DataType;\n  public res: Map<string, any> = new Map();\n  public getRes(path: Path) {\n    return getPath(this.res, path);\n  }\n  public setRes(path: Path, value: any) {\n    setPath(this.res, path, value);\n  }\n\n  #name?: string;\n  get name(): string {\n    if (!this.#name) {\n      this.#name = 'forestry-store:' + `${Math.random()}`.split('.').pop();\n    }\n    return this.#name!;\n  }\n\n  complete(): DataType {\n    if (!this.isActive) {\n      return this.value;\n    }\n\n    const finalValue = this.value;\n    this.isActive = false;\n\n    // Complete the RxJS subject\n    if (this.#subject) {\n      this.#subject.complete();\n    }\n\n    // Clear pending state\n    this.clearPending();\n\n    return finalValue;\n  }\n\n  isActive: boolean = true;\n  protected pending: DataType | undefined;\n  private _hasPending: boolean = false;\n\n  next(value: Partial<DataType>): boolean {\n    if (!this.isActive) {\n      throw new Error('Cannot update completed store');\n    }\n\n    // Apply prep function if it exists to transform partial input to complete data\n    const preparedValue = this.prep\n      ? this.prep(value, this.value, this.initialValue)\n      : (value as DataType);\n\n    const { isValid, error } = this.validate(preparedValue);\n    if (!this.subject) {\n      throw new Error('Store requires subject -- or override of next()');\n    }\n    if (isValid) {\n      this.#subject!.next(preparedValue);\n      return true;\n    }\n    if (this.debug) {\n      console.error(\n        'cannot update ',\n        this.name,\n        'with',\n        value,\n        '(current: ',\n        this.value,\n        ')',\n        error,\n      );\n    }\n    throw asError(error);\n  }\n\n  #test(fn: ValueTestFn<DataType>, value: unknown) {\n    const result = fn(value, this);\n    if (result) {\n      throw asError(result);\n    }\n    // no result/output for valid elements\n  }\n\n  validate(value: unknown) {\n    try {\n      if (isZodParser(this.schema)) {\n        this.schema.parse(value); // throws an error if the value is not valid\n      }\n      if (this.tests) {\n        if (Array.isArray(this.tests)) {\n          for (const test of this.tests) {\n            this.#test(test, value);\n          }\n        } else if (typeof this.tests === 'function') {\n          this.#test(this.tests, value);\n        } else {\n          throw new Error(\n            'bad value for tests - must be function or array of functions',\n          );\n        }\n      }\n      return {\n        isValid: true,\n      };\n    } catch (e) {\n      return {\n        isValid: false,\n        error: asError(e),\n      };\n    }\n  }\n\n  isValid(value: unknown): boolean {\n    return this.validate(value).isValid;\n  }\n\n  schema?: ZodParser;\n\n  tests?: ValueTestFn<DataType> | ValueTestFn<DataType>[];\n\n  // Pending value management\n  setPending(value: DataType): void {\n    if (this._hasPending) {\n      throw new Error('cannot overwrite a pending value');\n    }\n    this.pending = value;\n    this._hasPending = true;\n  }\n\n  hasPending(): boolean {\n    return this._hasPending;\n  }\n\n  clearPending(): void {\n    this.pending = undefined;\n    this._hasPending = false;\n  }\n\n  get value() {\n    if (this._hasPending) {\n      return this.pending;\n    }\n    if (!this.#subject) {\n      throw new Error('Store requires subject or overload of value');\n    }\n    return this.#subject.value as DataType;\n  }\n\n  subscribe(listener: Listener<DataType>): Subscription {\n    return this.subject!.pipe(distinctUntilChanged(isEqual)).subscribe(\n      listener,\n    );\n  }\n\n  get(path?: Path): any {\n    if (!path || (Array.isArray(path) && path.length === 0)) {\n      return this.value;\n    }\n    const pathArray = Array.isArray(path) ? path : pathString(path).split('.');\n    return getPath(this.value, pathArray);\n  }\n\n  mutate(producerFn: (draft: any) => void, path?: Path): any {\n    if (!path || (Array.isArray(path) && path.length === 0)) {\n      // Mutate the entire state\n      const newValue = produce(this.value, producerFn);\n      this.next(newValue);\n      return this.value;\n    } else {\n      // Mutate a specific path within the state\n      const pathArray = Array.isArray(path)\n        ? path\n        : pathString(path).split('.');\n      const newValue = produce(this.value, (draft) => {\n        // Get the target object at the specified path\n        const target = getPath(draft, pathArray);\n        if (target !== undefined) {\n          // Apply the producer function to the target\n          producerFn(target);\n        }\n      });\n      this.next(newValue);\n      return this.value;\n    }\n  }\n}\n"],"names":[],"mappings":"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"}