{"version":3,"file":"ForestBranch.js","sources":["../../src/Stores/ForestBranch.ts"],"sourcesContent":["import {\n  ActionExposedRecord,\n  Listener,\n  Path,\n  StoreBranch,\n  ForestMessage,\n  BranchParams,\n} from '../types';\nimport { Store } from './Store';\nimport { isStore } from '../typeguards';\nimport { get, isEqual } from 'lodash-es';\nimport combinePaths, { pathString } from '../lib/combinePaths';\nimport { map, Subject, Subscription } from 'rxjs';\nimport { distinctUntilChanged } from 'rxjs/operators';\nimport { produce } from 'immer';\nimport { getPath, setPath } from '../lib/path';\n\n/**\n * ForestBranch is a shard store for a forest;\n * it cannot be the root and it always must have parent and path.\n */\nexport class ForestBranch<DataType, Actions extends ActionExposedRecord = ActionExposedRecord>\n  extends Store<DataType, Actions>\n  implements StoreBranch<DataType, Actions>\n{\n  constructor(\n    p: BranchParams<DataType, Actions>,\n    public readonly path: Path,\n    public readonly parent: StoreBranch<unknown>\n  ) {\n    if (!isStore(parent)) {\n      throw new Error('ForestBranches must have parents');\n    }\n\n    const branchValue = getPath(parent.value, path) as DataType;\n    super(\n      {\n        ...p,\n        value: branchValue,\n      },\n      true\n    );\n\n    this.#parentSub = parent.receiver.subscribe((message) => {\n      this.handleMessage(message);\n    });\n  }\n\n  #parentSub: Subscription;\n\n  // Handle messages from parent/root\n  private handleMessage(message: any): void {\n    if (message && typeof message === 'object' && message.type) {\n      const forestMessage = message as ForestMessage;\n\n      switch (forestMessage.type) {\n        case 'set-pending':\n          this.setPendingFromRoot(forestMessage.payload);\n          break;\n        case 'validate-all':\n          this.validateAndReport();\n          // Clear pending value after validation\n          this.clearPending();\n          break;\n        case 'complete':\n          // Complete this branch when receiving complete message\n          this.complete();\n          break;\n      }\n    }\n\n    // Continue broadcasting to children\n    this.broadcast(message, true);\n  }\n\n  // Set pending value from root's new value\n  private setPendingFromRoot(rootValue: any): void {\n    const pendingValue = getPath(rootValue, this.path) as DataType;\n    this.setPending(pendingValue);\n  }\n\n  // Override value getter to return pending value during validation or parent value\n  get value(): DataType {\n    if (this.hasPending()) {\n      return this.pending!;\n    }\n    return getPath(this.parent?.value, this.path) as DataType;\n  }\n\n  // Validate current state and report failures to root\n  private validateAndReport(): void {\n    const { isValid, error } = this.validate(this.value);\n\n    if (!isValid) {\n      // Send validation failure message upstream\n      const failureMessage: ForestMessage = {\n        type: 'validation-failure',\n        branchPath: this.path,\n        error: typeof error === 'string' ? error : error?.toString() || 'Unknown validation error',\n        timestamp: Date.now(),\n      };\n\n      // Broadcast the failure message upstream (don't use fromRoot=true)\n      this.broadcast(failureMessage);\n    }\n  }\n\n  get root() {\n    let root = this.parent;\n    while (!root.isRoot && root.parent) {\n      root = root.parent;\n    }\n    return root;\n  }\n\n  get isRoot() {\n    return !this.parent;\n  }\n\n  next(value: Partial<DataType>): boolean {\n    if (!this.isActive) {\n      throw new Error('Cannot update completed store');\n    }\n\n    // Apply prep function if it exists to transform partial input to complete data\n    const preparedValue = this.prep\n      ? this.prep(value, this.value, this.initialValue)\n      : (value as DataType);\n\n    // Calculate what the new root value would be\n    const newRootValue = produce(this.parent.value, (draft) => {\n      setPath(draft, this.path, preparedValue);\n    });\n\n    // Use the root's next method which will handle validation of all branches\n    return this.root.next(newRootValue);\n  }\n\n  get subject() {\n    const path = pathString(this.path);\n    return this.parent.subject.pipe(\n      map((value) => get(value, path)),\n      distinctUntilChanged(isEqual)\n    );\n  }\n\n  subscribe(listener: Listener<DataType>) {\n    return this.subject.subscribe(listener);\n  }\n\n  set(path: Path, value: unknown): boolean {\n    if (this.parent) {\n      const deepPath = combinePaths(this.path, path);\n      return this.parent.set(deepPath, value);\n    } else {\n      // should be in Forest class instance but just in case:\n      // Use Immer to create immutable update\n      const pathArray = Array.isArray(path) ? path : pathString(path).split('.');\n      const newValue = produce(this.value, (draft) => {\n        setPath(draft, pathArray, value);\n      });\n      return this.next(newValue);\n    }\n  }\n\n  public receiver = new Subject();\n\n  public broadcast(message: unknown, fromRoot?: boolean) {\n    if (fromRoot || this.isRoot) {\n      this.receiver.next(message);\n    } else if (this.parent) {\n      this.parent.broadcast(message);\n    } else {\n      console.warn('strange broadcast pattern; node that is not root has no parent');\n    }\n  }\n\n  branch<Type, BranchActions extends ActionExposedRecord = ActionExposedRecord>(\n    path: Path,\n    params: BranchParams<Type, BranchActions>\n  ) {\n    const mergedPath = combinePaths(this.path, path);\n    const name = this.name + '.' + pathString(path);\n    return new ForestBranch<Type, BranchActions>(\n      {\n        name,\n        ...params,\n      },\n      mergedPath,\n      this // Use this branch as parent, not root\n    );\n  }\n\n  // Override complete to handle branch-specific completion\n  complete(): DataType {\n    if (!this.isActive) {\n      return this.value; // Multiple completes have no effect\n    }\n\n    // Send completion message to sub-branches\n    const completionMessage: ForestMessage = {\n      type: 'complete',\n      timestamp: Date.now(),\n    };\n    this.broadcast(completionMessage, true);\n\n    // Complete this branch (sets isActive to false)\n    const finalValue = super.complete();\n\n    // Complete the receiver subject after broadcasting\n    this.receiver.complete();\n\n    // Clean up parent subscription\n    this.#parentSub.unsubscribe();\n\n    return finalValue;\n  }\n\n  // Clean up when branch is destroyed\n  destroy(): void {\n    this.#parentSub.unsubscribe();\n  }\n}\n"],"names":[],"mappings":"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"}