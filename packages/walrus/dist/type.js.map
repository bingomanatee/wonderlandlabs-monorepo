{"version":3,"file":"type.js","sources":["../src/type.ts"],"sourcesContent":["import {\n  FormEnum,\n  NumberEnum,\n  NumberEnumType,\n  TypeEnum,\n  TypeofEnum,\n} from \"./enums\";\nimport type { TypeEnumType, FormEnumType } from \"./enums\";\n\ntype testFn = (value: any) => boolean;\n\nexport class TypeDef {\n  constructor(\n    public readonly type: TypeEnumType,\n    public readonly form: FormEnumType,\n    public readonly typeOf: TypeEnumType,\n    private test?: testFn,\n  ) {}\n\n  /**\n   * A very flat subspecies of FormEnum -- includes either 'void', 'scalar', 'function', or 'container'\n   */\n  get family() {\n    if (\n      [FormEnum.scalar, FormEnum.void, FormEnum.function].includes(this.form)\n    ) {\n      return this.form;\n    }\n    return FormEnum.container;\n  }\n\n  includes(value: any, typeOf?: TypeEnumType | string): boolean {\n    if (!typeOf) {\n      return this.includes(value, typeof value);\n    }\n    if (typeOf !== this.typeOf) {\n      return false;\n    }\n    if (this.test && !this.test(value)) {\n      return false;\n    }\n    return true; // same type as typeof, and no test to fail OR passed test\n  }\n}\n\nexport const types: TypeDef[] = [\n  new TypeDef(TypeEnum.undefined, FormEnum.void, TypeofEnum.undefined),\n  new TypeDef(\n    TypeEnum.null,\n    FormEnum.void,\n    TypeofEnum.object,\n    (s) => s === null,\n  ),\n  new TypeDef(TypeEnum.boolean, FormEnum.scalar, TypeofEnum.boolean),\n  new TypeDef(TypeEnum.string, FormEnum.scalar, TypeofEnum.string),\n  new TypeDef(TypeEnum.number, FormEnum.scalar, TypeofEnum.number),\n  new TypeDef(TypeEnum.number, FormEnum.scalar, TypeofEnum.bigint),\n  new TypeDef(TypeEnum.symbol, FormEnum.scalar, TypeofEnum.symbol),\n  new TypeDef(TypeEnum.function, FormEnum.function, TypeofEnum.function),\n  new TypeDef(TypeEnum.array, FormEnum.array, TypeofEnum.object, (v) =>\n    Array.isArray(v),\n  ),\n  new TypeDef(\n    TypeEnum.map,\n    FormEnum.map,\n    TypeofEnum.object,\n    (m) => m instanceof Map,\n  ),\n  new TypeDef(\n    TypeEnum.set,\n    FormEnum.set,\n    TypeofEnum.object,\n    (s) => s instanceof Set,\n  ),\n  new TypeDef(\n    TypeEnum.object,\n    FormEnum.object,\n    TypeofEnum.object,\n    (o) => o && typeof o === \"object\",\n  ),\n];\n\nexport function typeToForm(type: TypeEnumType): FormEnumType {\n  const d = types.find((d) => d.type === type);\n  return d?.form || FormEnum.void;\n}\n\nexport const describe = (\n  value: any,\n  reflect: string | boolean = false,\n): TypeDef | TypeEnumType | FormEnumType => {\n  if (reflect) {\n    const t: TypeDef = describe(value) as TypeDef;\n    if (typeof t === \"object\") {\n      if (reflect === true) {\n        return t.type;\n      }\n      if (\n        reflect === \"type\" ||\n        reflect === \"form\" ||\n        reflect === \"typeOf\" ||\n        reflect === \"family\"\n      ) {\n        return t[reflect];\n      }\n    }\n    return t;\n  }\n  const type = typeof value;\n  for (let i = 0; i < types.length; ++i) {\n    const def = types[i];\n    if (def.includes(value, type)) {\n      return def;\n    }\n  }\n  console.error(\"describe failure to analyze\", value);\n  throw new Error(\"cannot analyze value\");\n};\n\nexport const describeNumber = (value: any): NumberEnumType => {\n  if ([\"number\", \"bigint\"].includes(typeof value)) {\n    if (Number.isFinite(value)) {\n      if (Number.isInteger(value)) {\n        return NumberEnum.integer;\n      } else {\n        return NumberEnum.decimal;\n      }\n    } else {\n      return NumberEnum.infinite;\n    }\n  }\n  return NumberEnum.nan;\n};\n"],"names":["d"],"mappings":"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"}