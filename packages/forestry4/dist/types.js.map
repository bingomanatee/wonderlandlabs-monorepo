{"version":3,"file":"types.js","sources":["../src/types.ts"],"sourcesContent":["import { z } from 'zod';\n\nimport { Subject, Subscription, Observer, Observable } from 'rxjs';\nimport { ZodParser } from './typeguards';\n\n// these are the actions as defined, in the params\nexport type ActionParamsFn<\n  DataType = unknown,\n  Args extends readonly unknown[] = any[],\n  Returned = any | void,\n> = (value: DataType, ...args: Args) => Returned;\n\n// these are the actions as exposed in the state\nexport type ActionExposedFn<\n  Args extends readonly unknown[] = any[],\n  Returned = any | void,\n> = (...args: Args) => Returned;\n\nexport type ActionParamsRecord = Record<string, ActionParamsFn>;\nexport type ActionExposedRecord = Record<string, ActionExposedFn>;\n// Utility type to transform ActionParamsFn to ActionExposedFn (removes first parameter)\nexport type TransformActionMethod<T> = T extends (\n  value: any,\n  ...args: infer Args\n) => infer Return\n  ? (...args: Args) => Return\n  : T;\n\n// Utility type to transform an entire ActionParamsRecord to ActionExposedRecord\nexport type TransformActionRecord<T extends ActionParamsRecord> = {\n  [K in keyof T]: TransformActionMethod<T[K]>;\n};\n\n// Utility type to infer the exposed Actions type from ActionParamsRecord\nexport type InferExposedActions<T extends ActionParamsRecord> =\n  TransformActionRecord<T>;\n\n// Utility type to convert exposed ActionExposedRecord back to ActionParamsRecord (adds value parameter)\nexport type RecordToParams<\n  T extends ActionExposedRecord,\n  DataType = unknown,\n> = {\n  [K in keyof T]: T[K] extends (...args: infer Args) => infer Return\n    ? (value: DataType, ...args: Args) => Return\n    : never;\n};\nexport type ValueTestFn<DataType> = (\n  value: unknown,\n  store: StoreIF<DataType>,\n) => null | void | string;\n\nexport type Listener<DataType> =\n  | Partial<Observer<DataType>>\n  | ((value: DataType) => void);\n\nexport const sources: Record<string, string> = {\n  TRANSACTION: 'transaction',\n  NEXT: 'next',\n};\n\nexport type PendingValue<DataType> = {\n  id: string;\n  value: DataType;\n  rollbackValue?: DataType;\n  source: string;\n  suspendValidation?: boolean;\n};\n\n// Validation result type\nexport type ValidationResult = string | null; // null = valid, string = error message\n\n// Forest messaging system for validation\nexport interface ForestMessage {\n  type:\n    | 'set-pending'\n    | 'validate-all'\n    | 'validation-failure'\n    | 'validation-complete'\n    | 'complete';\n  payload?: any;\n  branchPath?: Path;\n  error?: string;\n  timestamp: number;\n}\n\nexport type Validity = {\n  isValid: boolean;\n  error?: Error;\n};\n\nexport interface StoreIF<\n  DataType,\n  Actions extends ActionExposedRecord = ActionExposedRecord,\n> {\n  value: DataType;\n  name: string;\n\n  subscribe(listener: Listener<DataType>): Subscription;\n\n  acts: Actions;\n  $: Actions;\n  next: (value: Partial<DataType>) => boolean;\n\n  // Pending value management\n  setPending: (value: DataType) => string;\n  hasPending: () => boolean;\n\n  // Resource map for non-immutable external resources (DOM, WebGL, etc.)\n  res: Map<string, any>;\n  getRes(path: Path): any;\n  setRes(path: Path, value: any): void;\n\n  complete: () => DataType;\n  isActive: boolean;\n\n  // validators\n  schema?: ZodParser;\n  tests?: ValueTestFn<DataType> | ValueTestFn<DataType>[];\n  prep?: (\n    input: Partial<DataType>,\n    current: DataType,\n    initial: DataType,\n  ) => DataType;\n\n  validate(value: unknown): Validity;\n\n  isValid(value: unknown): boolean;\n\n  // Core utility methods\n  get(path?: Path): any;\n  mutate(producerFn: (draft: DataType) => void, path?: Path): DataType;\n\n  transact<Type = DataType>(\n    fn: TransFn<Type>,\n    suspendValidation?: boolean,\n    target?: StoreIF<Type>,\n  ): DataType;\n}\n\nexport type TransFn<DataType> = (store: StoreIF<DataType>) => void;\n\nexport interface StoreBranch<\n  DataType,\n  Actions extends ActionExposedRecord = ActionExposedRecord,\n> extends StoreIF<DataType, Actions> {\n  path: Path;\n  fullPath: Path;\n  root: StoreBranch<unknown>;\n  isRoot: boolean;\n  parent?: StoreBranch<unknown>;\n  broadcast: (message: unknown, fromRoot?: boolean) => void;\n  suspendValidation: boolean;\n  receiver: Subject<unknown>;\n  set(path: Path, value: unknown): boolean;\n  subject: Observable<DataType>;\n  branch<Type, BranchActions extends ActionExposedRecord = ActionExposedRecord>(\n    path: Path,\n    params: BranchParams<Type, BranchActions>,\n  ): StoreBranch<Type, BranchActions>;\n}\n\n// Resource map for managing non-immutable external resources\nexport type ResourceMap = Map<string, any>;\n\nexport type StoreParams<\n  DataType,\n  Actions extends ActionExposedRecord = ActionExposedRecord,\n> = {\n  value: DataType;\n  actions?: RecordToParams<Actions, DataType>; // Input actions always have value as first parameter\n  schema?: z.ZodSchema<DataType>;\n  tests?: ValueTestFn<DataType> | ValueTestFn<DataType>[];\n  prep?: (\n    input: Partial<DataType>,\n    current: DataType,\n    initial: DataType,\n  ) => DataType;\n  resources?: ResourceMap;\n  name?: string;\n  debug?: boolean;\n  res?: Map<string, any>;\n};\n\n// Specific type for branch parameters that properly types the actions\nexport type BranchParams<\n  DataType,\n  Actions extends ActionExposedRecord = ActionExposedRecord,\n> = {\n  actions?: RecordToParams<Actions, DataType>;\n  schema?: z.ZodSchema<DataType>;\n  tests?: ValueTestFn<DataType> | ValueTestFn<DataType>[];\n  prep?: (\n    input: Partial<DataType>,\n    current: DataType,\n    initial: DataType,\n  ) => DataType;\n  name?: string;\n  debug?: boolean;\n};\n\ntype PathElement = string;\n\nexport type Path = PathElement[] | string;\n"],"names":[],"mappings":"AAuDO,MAAM,UAAkC;AAAA,EAC7C,aAAa;AAAA,EACb,MAAM;AACR;"}