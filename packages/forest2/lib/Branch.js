Object.defineProperty(exports,"__esModule",{value:!0}),exports.Branch=void 0;let types_guards_1=require("./types/types.guards"),isCacheable_1=require("./isCacheable");class Branch{constructor(e,t){this.tree=e,this.change=t,this._hasBeenCached=null,this.time=e.forest.nextTime}get cause(){return this.change.name}get next(){return this._next}set next(e){if(this===e)throw new Error("cannot self recurse");if(e&&this.prev===e)throw new Error("cannot self recurse loop");this._next=e}get prev(){return this._prev}set prev(e){if(this.prev===e)throw new Error("cannot self-recurse");if(e&&this.next===e)throw new Error("cannot self recurse loop");this._prev=e}add(e){if(this.next)throw new Error("can only add at the end of a chain");e=new Branch(this.tree,e);return this.link(this,e),e}_cacheValue(e){this._cached=e,this._hasBeenCached=!0}get value(){if(!0===this._hasBeenCached)return this._cached;if((0,types_guards_1.isAssert)(this.change))return this.change.assert;var e;if((0,types_guards_1.isMutator)(this.change))return e=this.change.mutator(this.prev,this.change.seed),!1!==this._hasBeenCached&&(!this.tree.isUncacheable&&(0,isCacheable_1.isCacheable)(e)?this._cacheValue(e):this._hasBeenCached=!1),e;throw new Error("impossible change type")}linkTo(e){return this.link(this,e)}link(e,t){e&&(e.next=t),t&&(t.prev=e)}toString(){return`branch ${this.time} of tree {${this.tree.name??"(anon)"}} - value = ${this.value} next=${this.next?this.next.time:"<null>"} prev=`+(this.prev?this.prev.time:"<null>")}destroy(){this.next=null,this.prev=null,this._cacheValue=void 0,this.tree=void 0,this.change=void 0}}exports.Branch=Branch;