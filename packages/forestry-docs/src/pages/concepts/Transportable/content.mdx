Because trees are class instances they are transportable: they can be
instantiated for individual components, or kept globally as resources that can
be subscribed to by any component that needs access to their data or methods.

They can be used in React Native, and can also be used in "not React" 
- Angular, Vue or general purpose Javascript applications, or web workers.

In fact they are not at all dependent on Browser context 
and can be used in a server.

## Aren't classes evil?

No they are not. relying on deep inheritance and overreliance on intelligent properties may be
unhealthy but as a cluster of behaviors and methods with a known ecosystem of values is not an
inherently unhealthy pattern. Plenty of healthy systems rely on classes including RxDB, Firebase,
Mapbox, Pixi, Three.js, and hundreds more. Functional design is a good architecture, but it does
not always deliver everything that every use case demands. And the existence of a useful
architectural pattern doesn't eliminate the utility of other patterns of engineering.

In Forestry, change methods and managed state are connected using references and class management
systems. The actual value of states are not (necessarily) classes; in fact there is no inherent constraint
on the subject of a tree. But the connections that classes maintain are useful conventions in this
particular system.

## Testing Trees

Trees can be tested absent of their view to validate business concepts.
This is 1000% more efficient than mocking up and simulting user interactions
in a headless view scenario. Changes to business values operate in their own
sphere, and shouldn't be dependent on the view that expresses their state
out to the DOM.

Here is the unit test suite for the Eggs example from [Transactional](/contents/transactional):

```JavaScript

type Egg = {
  id: string;
  daysLeft: number;
};
describe('concepts', () => {
  describe('transactional', () => {
    it('should rollback collections', () => {
      const f = new Forest();

      type Egg = {
        id: string;
        daysLeft: number;
      };

      const EXPIRED_MSG = 'Egg has expired';
      const eggValidator = (e: Egg) => {
        if (e.daysLeft <= 0) {
          throw new Error(EXPIRED_MSG);
        }
      };
      const eggsValidator = (es: Egg[]) => {
        for (const e of es) {
          eggValidator(e);
        }
      };

      const INITIAL = [
        { id: 'alpha', daysLeft: 4 },
        { id: 'beta', daysLeft: 3 },
        { id: 'gamma', daysLeft: 2 },
      ];

      const LESS_ONE_DAY = [
        { id: 'alpha', daysLeft: 3 },
        { id: 'beta', daysLeft: 2 },
        { id: 'gamma', daysLeft: 1 },
      ];

      const eggs = new Collection<Egg[]>(
        'eggs',
        {
          initial: INITIAL,
          validator: eggsValidator,
          actions: {
            removeADay(coll: CollectionIF<Egg[]>) {
              for (const egg of coll.value) {
                coll.act('removeEggDay', egg.id);
              }
            },
            removeEggDay(coll: CollectionIF<Egg[]>, id: string) {
              const eggs: Egg[] = coll.value.map((egg) => {
                if (egg.id === id) {
                  return { ...egg, daysLeft: egg.daysLeft - 1 };
                }
                return egg;
              });
              coll.next(eggs);
            },
            removeEgg(coll: CollectionIF<Egg[]>, id: string) {
              coll.mutate(({ value }) => {
                const out = value.filter((egg: Egg) => egg.id !== id);
                return out;
              }, 'removing egg ' + id);
            },
            removeADayWithCatch(coll: CollectionIF<Egg[]>) {
              for (const egg of coll.value) {
                try {
                  coll.act('removeEggDay', egg.id);
                } catch (error) {
                  if (error instanceof Error && error.message === EXPIRED_MSG) {
                    coll.act('removeEgg', egg.id);
                  } else {
                    throw error;
                  }
                }
              }
            },
          },
        },
        f
      );

      expect(eggs.value).toEqual(INITIAL);

      eggs.act('removeADay');

      expect(eggs.value).toEqual(LESS_ONE_DAY);

      expect(() => eggs.act('removeADay')).toThrow();

      expect(eggs.value).toEqual(LESS_ONE_DAY);

      eggs.act('removeADayWithCatch');
      expect(eggs.value).toEqual([
        { id: 'alpha', daysLeft: 2 },
        { id: 'beta', daysLeft: 1 },
      ]);
    });

    it('should observe change', () => {
      const f = new Forest();

      const EXPIRED_MSG = 'Egg has expired';
      const eggValidator = (e: Egg) => {
        if (e.daysLeft <= 0) {
          throw new Error(EXPIRED_MSG);
        }
      };
      const eggsValidator = (es: Egg[]) => {
        for (const e of es) {
          eggValidator(e);
        }
      };

      const INITIAL = [
        { id: 'alpha', daysLeft: 4 },
        { id: 'beta', daysLeft: 3 },
        { id: 'gamma', daysLeft: 2 },
      ];

      const eggsCollection = new Collection<Egg[]>(
        'eggs',
        {
          initial: INITIAL,
          validator: eggsValidator,
          actions: {
            removeADay(coll: CollectionIF<Egg[]>) {
              for (const egg of coll.value) {
                coll.act('removeEggDay', egg.id);
              }
            },
            removeEggDay(coll: CollectionIF<Egg[]>, id: string) {
              const eggs: Egg[] = coll.value.map((egg) => {
                if (egg.id === id) {
                  return { ...egg, daysLeft: egg.daysLeft - 1 };
                }
                return egg;
              });
              coll.next(eggs);
            },
            removeEgg(coll: CollectionIF<Egg[]>, id: string) {
              coll.mutate(({ value }) => {
                const out = value.filter((egg: Egg) => egg.id !== id);
                console.log('out after rmoving', id, 'is', out);
                return out;
              }, 'removing egg ' + id);
            },
            removeADayWithCatch(coll: CollectionIF<Egg[]>) {
              for (const egg of coll.value) {
                try {
                  coll.act('removeEggDay', egg.id);
                } catch (error) {
                  if (error instanceof Error && error.message === EXPIRED_MSG) {
                    coll.act('removeEgg', egg.id);
                  } else {
                    throw error;
                  }
                }
              }
            },
          },
        },
        f
      );

      type EggSummary = Record<string, number>;

      function summary(eggs: Egg[]): EggSummary {
        const out: EggSummary = {};
        for (const egg of eggs) {
          out[egg.id] = egg.daysLeft;
        }
        return out;
      }

      type EggTimer = {
        time: number;
        eggs: EggSummary;
        source: string;
        act: string;
      };
      const log: EggTimer[] = [];

      f.observe('eggs').subscribe((eggs: Egg[]) => {
        log.push({
          eggs: summary(eggs),
          time: f.time,
          source: 'observe',
          act: eggsCollection.tree.top?.cause,
        });
      });

      eggsCollection.tree.subscribe((eggs: Egg[]) => {
        log.push({
          eggs: summary(eggs),
          time: f.time,
          source: 'tree.subscribe',
          act: eggsCollection.tree.top?.cause,
        });
      });

      eggsCollection.act('removeADay');
      eggsCollection.act('removeADayWithCatch');

      expect(log).toEqual([
        {
          eggs: {
            alpha: 4,
            beta: 3,
            gamma: 2,
          },
          time: 1,
          source: 'observe',
          act: 'INITIAL VALUE',
        },
        {
          eggs: {
            alpha: 4,
            beta: 3,
            gamma: 2,
          },
          time: 1,
          source: 'tree.subscribe',
          act: 'INITIAL VALUE',
        },
        {
          eggs: {
            alpha: 3,
            beta: 3,
            gamma: 2,
          },
          time: 5,
          source: 'tree.subscribe',
          act: '(next)',
        },
        {
          eggs: {
            alpha: 3,
            beta: 2,
            gamma: 2,
          },
          time: 8,
          source: 'tree.subscribe',
          act: '(next)',
        },
        {
          eggs: {
            alpha: 3,
            beta: 2,
            gamma: 1,
          },
          time: 11,
          source: 'tree.subscribe',
          act: '(next)',
        },
        {
          eggs: {
            alpha: 3,
            beta: 2,
            gamma: 1,
          },
          time: 11,
          source: 'observe',
          act: '(next)',
        },
        {
          eggs: {
            alpha: 2,
            beta: 2,
            gamma: 1,
          },
          time: 15,
          source: 'tree.subscribe',
          act: '(next)',
        },
        {
          eggs: {
            alpha: 2,
            beta: 1,
            gamma: 1,
          },
          time: 18,
          source: 'tree.subscribe',
          act: '(next)',
        },
        {
          eggs: {
            alpha: 2,
            beta: 1,
            gamma: 1,
          },
          time: 20,
          source: 'observe',
          act: '(next)',
        },
        {
          eggs: {
            alpha: 2,
            beta: 2,
            gamma: 1,
          },
          time: 24,
          source: 'tree.subscribe',
          act: '(next)',
        },
        {
          eggs: {
            alpha: 2,
            beta: 1,
            gamma: 1,
          },
          time: 27,
          source: 'tree.subscribe',
          act: '(next)',
        },
        {
          eggs: {
            alpha: 2,
            beta: 1,
          },
          time: 32,
          source: 'tree.subscribe',
          act: 'removing egg gamma',
        },
        {
          eggs: {
            alpha: 2,
            beta: 1,
          },
          time: 32,
          source: 'observe',
          act: 'removing egg gamma',
        },
      ]);
    });
  });
});


