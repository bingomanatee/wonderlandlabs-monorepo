Because trees are class instances they are transportable: they can be
instantiated for individual components, or kept globally as resources that can
be subscribed to by any component that needs access to their data or methods.

They can be used in React Native, and can also be used in "not React" 
- Angular, Vue or general purpose Javascript applications, or web workers.

In fact they are not at all dependent on Browser context 
and can be used in a server.

## Aren't classes evil?

No they are not. relying on deep inheritance and overreliance on intelligent properties may be
unhealthy but as a cluster of behaviors and methods with a known ecosystem of values is not an
inherently unhealthy pattern. Plenty of healthy systems rely on classes including RxDB, Firebase,
Mapbox, Pixi, Three.js, and hundreds more. Functional design is a good architecture, but it does
not always deliver everything that every use case demands. And the existence of a useful
architectural pattern doesn't eliminate the utility of other patterns of engineering.

In Forestry, change methods and managed state are connected using references and class management
systems. The actual value of states are not (necessarily) classes; in fact there is no inherent constraint
on the subject of a tree. But the connections that classes maintain are useful conventions in this
particular system.

## Testing Trees

Trees can be tested absent of their view to validate business concepts.
This is 1000% more efficient than mocking up and simulting user interactions
in a headless view scenario. Changes to business values operate in their own
sphere, and shouldn't be dependent on the view that expresses their state
out to the DOM.

Here is the unit test suite for the Eggs example from [Transactional](/contents/transactional):

```JavaScript

type Egg = {
  id: string;
  daysLeft: number;
};
describe('concepts', () => {
  describe('transactional', () => {
    it('should rollback collections', () => {
      const f = new Forest();

      type Egg = {
        id: string;
        daysLeft: number;
      };

      const EXPIRED_MSG = 'Egg has expired';
      const eggValidator = (e: Egg) => {
        if (e.daysLeft <= 0) {
          throw new Error(EXPIRED_MSG);
        }
      };
      const eggsValidator = (es: Egg[]) => {
        for (const e of es) {
          eggValidator(e);
        }
      };

      const INITIAL = [
        { id: 'alpha', daysLeft: 4 },
        { id: 'beta', daysLeft: 3 },
        { id: 'gamma', daysLeft: 2 },
      ];

      const LESS_ONE_DAY = [
        { id: 'alpha', daysLeft: 3 },
        { id: 'beta', daysLeft: 2 },
        { id: 'gamma', daysLeft: 1 },
      ];

      const eggs = new Collection<Egg[]>(
        'eggs',
        {
          initial: INITIAL,
          validator: eggsValidator,
          actions: {
            removeADay(coll: CollectionIF<Egg[]>) {
              for (const egg of coll.value) {
                coll.act('removeEggDay', egg.id);
              }
            },
            removeEggDay(coll: CollectionIF<Egg[]>, id: string) {
              const eggs: Egg[] = coll.value.map((egg) => {
                if (egg.id === id) {
                  return { ...egg, daysLeft: egg.daysLeft - 1 };
                }
                return egg;
              });
              coll.next(eggs);
            },
            removeEgg(coll: CollectionIF<Egg[]>, id: string) {
              coll.mutate(({ value }) => {
                const out = value.filter((egg: Egg) => egg.id !== id);
                return out;
              }, 'removing egg ' + id);
            },
            removeADayWithCatch(coll: CollectionIF<Egg[]>) {
              for (const egg of coll.value) {
                try {
                  coll.act('removeEggDay', egg.id);
                } catch (error) {
                  if (error instanceof Error && error.message === EXPIRED_MSG) {
                    coll.act('removeEgg', egg.id);
                  } else {
                    throw error;
                  }
                }
              }
            },
          },
        },
        f
      );

      expect(eggs.value).toEqual(INITIAL);

      eggs.act('removeADay');

      expect(eggs.value).toEqual(LESS_ONE_DAY);

      expect(() => eggs.act('removeADay')).toThrow();

      expect(eggs.value).toEqual(LESS_ONE_DAY);

      eggs.act('removeADayWithCatch');
      expect(eggs.value).toEqual([
        { id: 'alpha', daysLeft: 2 },
        { id: 'beta', daysLeft: 1 },
      ]);
    });

    it('should observe change', () => {
      const f = new Forest();

      const EXPIRED_MSG = 'Egg has expired';
      const eggValidator = (e: Egg) => {
        if (e.daysLeft <= 0) {
          throw new Error(EXPIRED_MSG);
        }
      };
      const eggsValidator = (es: Egg[]) => {
        for (const e of es) {
          eggValidator(e);
        }
      };

      const INITIAL = [
        { id: 'alpha', daysLeft: 4 },
        { id: 'beta', daysLeft: 3 },
        { id: 'gamma', daysLeft: 2 },
      ];

      const eggsCollection = new Collection<Egg[]>(
        'eggs',
        {
          initial: INITIAL,
          validator: eggsValidator,
          actions: {
            removeADay(coll: CollectionIF<Egg[]>) {
              for (const egg of coll.value) {
                coll.act('removeEggDay', egg.id);
              }
            },
            removeEggDay(coll: CollectionIF<Egg[]>, id: string) {
              const eggs: Egg[] = coll.value.map((egg) => {
                if (egg.id === id) {
                  return { ...egg, daysLeft: egg.daysLeft - 1 };
                }
                return egg;
              });
              coll.next(eggs);
            },
            removeEgg(coll: CollectionIF<Egg[]>, id: string) {
              coll.mutate(({ value }) => {
                const out = value.filter((egg: Egg) => egg.id !== id);
                console.log('out after rmoving', id, 'is', out);
                return out;
              }, 'removing egg ' + id);
            },
            removeADayWithCatch(coll: CollectionIF<Egg[]>) {
              for (const egg of coll.value) {
                try {
                  coll.act('removeEggDay', egg.id);
                } catch (error) {
                  if (error instanceof Error && error.message === EXPIRED_MSG) {
                    coll.act('removeEgg', egg.id);
                  } else {
                    throw error;
                  }
                }
              }
            },
          },
        },
        f
      );

      type EggSummary = Record<string, number>;

      function summary(eggs: Egg[]): EggSummary {
        const out: EggSummary = {};
        for (const egg of eggs) {
          out[egg.id] = egg.daysLeft;
        }
        return out;
      }

      type EggTimer = {
        time: number;
        eggs: EggSummary;
        source: string;
        act: string;
      };
      const log: EggTimer[] = [];

      f.observe('eggs').subscribe((eggs: Egg[]) => {
        log.push({
          eggs: summary(eggs),
          time: f.time,
          source: 'observe',
          act: eggsCollection.tree.top?.cause,
        });
      });

      eggsCollection.tree.subscribe((eggs: Egg[]) => {
        log.push({
          eggs: summary(eggs),
          time: f.time,
          source: 'tree.subscribe',
          act: eggsCollection.tree.top?.cause,
        });
      });

      eggsCollection.act('removeADay');
      eggsCollection.act('removeADayWithCatch');

      expect(log).toEqual([
        {
          eggs: {
            alpha: 4,
            beta: 3,
            gamma: 2,
          },
          time: 1,
          source: 'observe',
          act: 'INITIAL VALUE',
        },
        {
          eggs: {
            alpha: 4,
            beta: 3,
            gamma: 2,
          },
          time: 1,
          source: 'tree.subscribe',
          act: 'INITIAL VALUE',
        },
        {
          eggs: {
            alpha: 3,
            beta: 3,
            gamma: 2,
          },
          time: 5,
          source: 'tree.subscribe',
          act: '(next)',
        },
        {
          eggs: {
            alpha: 3,
            beta: 2,
            gamma: 2,
          },
          time: 8,
          source: 'tree.subscribe',
          act: '(next)',
        },
        {
          eggs: {
            alpha: 3,
            beta: 2,
            gamma: 1,
          },
          time: 11,
          source: 'tree.subscribe',
          act: '(next)',
        },
        {
          eggs: {
            alpha: 3,
            beta: 2,
            gamma: 1,
          },
          time: 11,
          source: 'observe',
          act: '(next)',
        },
        {
          eggs: {
            alpha: 2,
            beta: 2,
            gamma: 1,
          },
          time: 15,
          source: 'tree.subscribe',
          act: '(next)',
        },
        {
          eggs: {
            alpha: 2,
            beta: 1,
            gamma: 1,
          },
          time: 18,
          source: 'tree.subscribe',
          act: '(next)',
        },
        {
          eggs: {
            alpha: 2,
            beta: 1,
            gamma: 1,
          },
          time: 20,
          source: 'observe',
          act: '(next)',
        },
        {
          eggs: {
            alpha: 2,
            beta: 2,
            gamma: 1,
          },
          time: 24,
          source: 'tree.subscribe',
          act: '(next)',
        },
        {
          eggs: {
            alpha: 2,
            beta: 1,
            gamma: 1,
          },
          time: 27,
          source: 'tree.subscribe',
          act: '(next)',
        },
        {
          eggs: {
            alpha: 2,
            beta: 1,
          },
          time: 32,
          source: 'tree.subscribe',
          act: 'removing egg gamma',
        },
        {
          eggs: {
            alpha: 2,
            beta: 1,
          },
          time: 32,
          source: 'observe',
          act: 'removing egg gamma',
        },
      ]);
    });
  });
});


```

## All Roads Lead to React

Here is a basic pattern for _local_ insertion of state in React:

```JavaScript

  type StateValues = {
    username: '',
    password: '',
  }

  function MyComponent() {

  const state = useRef<TreeIF<StateValues>>(appState());

  const [value, setValue] = useState(state.current.value);

  useEffect(() => {
    const sub = state.current?.subscribe((v) => setValue(v));
    () => sub?.unsubscribe();
  }, []);

      return (
        <div>
          <div>
            <label>Username</label>
            <input name="username" value={value.username}
            onChange={(e) => state.next({...state.value, username: e.target.value}))} />
          </div>
          <div>
            <label>Password</label>
            <input name="password" type="password" value={value.password}
            onChange={(e) => state.next({...state.value, password: e.target.value}))} />
          </div>

        </div>
      )

  }

  function appState () {
    const f = new Forest();

    t = f.addTree<StateValues>('login', {
      initial: {username: '', password: ''}
    })

    return tree;
  }

```

## A more involved example

This specific state is responsible for rotating the concepts panels on the home page
when they are not being interacted with, and freezing on the hovered-over panel
if the user moves the mouse over a panel.

```JavaScript
import { Forest } from "@wonderlandlabs/forestry";
import type { SubscribeFn } from "@wonderlandlabs/forestry/build/src/types/types.shared";
import type { TreeIF } from "@wonderlandlabs/forestry/build/src/types/types.trees";
import { debounce } from "lodash-es";
import type { PartialObserver } from "rxjs";

const SECONDS = 1000;
const LONG_DELAY = 5 * SECONDS;
const SHORT_DELAY = 2 * SECONDS;

export interface StateIF {
  target: string | null;
  time: number;
  list: string[];
  isLocked: boolean;
}

function setTarget(target: string, isLocked: boolean | null = null) {
  return ({ value }: { value: StateIF }) => {
    return {
      ...value,
      target,
      time: Date.now(),
      isLocked: isLocked === null ? value.isLocked : isLocked,
    };
  };
}

// note - this is a simple "wrapper around a tree" -
export class State {
  constructor(public tree: TreeIF<StateIF>) {
    // begins rotation after the last panel registers it as a target to be rotated to
    this.#init = debounce(() => this.init(), SHORT_DELAY);
  }

  // adds a candidate to be focused by name.
  register(target: string) {
    this.tree.mutate(({ value }) => ({
      ...value,
      list: [...value.list, target],
    }));

    this.#init?.();
  }

  handleHover(target: string | null) {
    clearInterval(this.#interval);
    this.tree.mutate(setTarget(target ?? "", true));
  }

// un-lock the state allowing passive rotate when the user leaves a panel
  blur() {
      this.tree.mutate(({ value }) => ({
        ...value,
        isLocked: false,
        target: "",
      }));
    this.delay(() => this.rotate(), LONG_DELAY);
  }

// focus on the next panel
  rotate(isLocked = false) {
    if (this.value.isLocked) return;
    const target = this.nextTarget();

    this.tree.mutate(({ value }) => ({
      ...value,
      target,
      time: Date.now(),
      isLocked,
    }));

    this.delay(() => this.rotate(), SHORT_DELAY);
  }

  #interval: any;

  // attempts to prevent any "dying gasp" actions if the page is left.
  destroy() {
    clearInterval(this.#interval);
  }

  // does an action later... only one delayed action at a time,
  // any previously queued action is cancelled.

  delay(f: () => void, delay: number) {
    clearInterval(this.#interval);
    this.#interval = setInterval(f, delay);
  }

  #init?: () => void;
  init() {
    this.delay(() => this.rotate(), LONG_DELAY);
  }

  // the name of the target after the current one.
  nextTarget() {
    const { list, target } = this.tree.value;
    if (!list.length) return "";
    const i = list.findIndex((t) => t === target) + 1;
    if (i >= list.length) return list[0];
    return list[i];
  }
  get value() {
    return this.tree.value;
  }

  subscribe(s: PartialObserver<StateIF> | SubscribeFn<StateIF>) {
    return this.tree.forest.observe(this.tree.name!)?.subscribe(s);
  }
}

export function appState() {
  const f = new Forest();

  const tree = f.addTree<StateIF>("state", {
    initial: { target: null, time: 0, list: [], isLocked: false },
  });

  return new State(tree);
}
```
