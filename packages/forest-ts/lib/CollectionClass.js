"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const ErrorPlus_1=require("./ErrorPlus"),walrus_1=require("@wonderlandlabs/walrus"),rxjs_1=require("rxjs"),collect_1=require("@wonderlandlabs/collect"),utils_1=require("./utils"),NAME_TEST=/^[a-z\-_$0-9]+$/;class CollectionClass{constructor(t,e,i){this.tree=t,this.config=e,this._validateConfig();const r=new Map;null!=i&&i.forEach(t=>{this.validate(t);var e=this.identityOf(t);r.set(e,t)}),this.subject=new rxjs_1.BehaviorSubject(r),this.subject.subscribe(()=>{this.tree.updates.next({action:"update-collection",collection:this.name})})}get values(){return this.subject.value}get fieldMap(){return this._fieldMap||(Array.isArray(this.config.fields)?this._fieldMap=this.config.fields.reduce((t,e)=>(t.set(e.name,e),t),new Map):(this._fieldMap=new Map,(0,collect_1.c)(this.config.fields).forEach((t,e)=>{"object"!=typeof t&&(t={type:t}),this._fieldMap.set(e,Object.assign(Object.assign({},t),{name:e}))}))),this._fieldMap}_validateConfig(){if(!this.config.identity)throw new ErrorPlus_1.ErrorPlus("collection config missing identity",this.config);switch(typeof this.config.identity){case"string":var t=this.fieldMap.get(this.config.identity);if(!t)throw new ErrorPlus_1.ErrorPlus("collection config identity must include identity field "+this.config.identity,this.config);if(t.optional)throw new ErrorPlus_1.ErrorPlus("collection identity field cannot be empty",this.config);break;case"function":break;default:throw new ErrorPlus_1.ErrorPlus("identity must be a string or function",{config:this.config})}if(!this.config.name||"string"!=typeof this.config.name||!NAME_TEST.test(this.config.name))throw new ErrorPlus_1.ErrorPlus("collections must have name")}get name(){return this.config.name}validate(r){this.fieldMap.forEach(t=>{if(t.name in r){var e=r[t.name],i=walrus_1.type.describe(e,!0);if(t.type)if(Array.isArray(t.type)){if(!t.type.includes(i))throw new ErrorPlus_1.ErrorPlus(`field ${t.name} does not match any allowed type`,{def:t,value:r,collection:this.name})}else if(i!==t.type)throw new ErrorPlus_1.ErrorPlus("field does not match allowed type",{type:t.type,field:t.name,value:r,collection:this.name});if(t.validator)if(t.validator(e,this))throw new ErrorPlus_1.ErrorPlus("failed validation filter for "+t.name,{field:t.name,value:r,collection:this.name})}else if(!t.optional)throw new ErrorPlus_1.ErrorPlus(`validation error: ${this.name} record missing required field `+t.name,{data:r,collection:this,field:t.name})})}identityOf(t){if("string"==typeof this.config.identity)return t[this.config.identity];if("function"==typeof this.config.identity)return this.config.identity(t,this);throw new ErrorPlus_1.ErrorPlus("config identity is not valid",{config:this.config,collection:this})}setValue(t){this.validate(t);var e=new Map(this.values),i=this.identityOf(t);return e.set(i,t),this.subject.next(e),i}put(t){return this.tree.do(()=>this.setValue(t))}get(t){return this.values.get(t)}query(e){if(e.collection&&e.collection!==this.name)throw new ErrorPlus_1.ErrorPlus(`cannot query ${this.name}with query for `+e.collection,e);const t=this,i=Object.assign({collection:this.name},e);return i.identity?this.subject.pipe((0,rxjs_1.takeWhile)(t=>t.has(e.identity)),(0,rxjs_1.distinctUntilChanged)((t,e)=>(0,utils_1.compareMaps)(t,e,i)),(0,rxjs_1.map)(()=>t._fetch(i))):this.subject.pipe((0,rxjs_1.distinctUntilChanged)((t,e)=>(0,utils_1.compareMaps)(t,e,i)),(0,rxjs_1.map)(()=>this._fetch(i)))}_fetch(t){const e=Object.assign({collection:this.name},t);return t.identity?this.has(t.identity)?[this.tree.leaf(this.name,t.identity,e)]:[]:Array.from(this.values.keys()).map(t=>this.tree.leaf(this.name,t,e))}has(t){return this.values.has(t)}fetch(t){if(t.collection&&t.collection!==this.name)throw new ErrorPlus_1.ErrorPlus(`cannot query ${this.name}with query for `+t.collection,t);return this._fetch(t)}}exports.default=CollectionClass;