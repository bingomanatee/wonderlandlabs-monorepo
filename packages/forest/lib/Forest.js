var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.Forest=void 0;let isString_1=require("./helpers/isString"),isLeafIdentityIF_1=require("./helpers/isLeafIdentityIF"),Tree_1=require("./Tree"),isLeafIF_1=require("./helpers/isLeafIF"),constants_1=require("./constants"),enums_1=require("./helpers/enums"),Scope_1=__importDefault(require("./Scope")),DEFAULT_CACHE_INTERVAL=8;function scopeError(e,t,r){return{...t,scope:e.scopeID,removed:r.map(e=>e.scopeID)}}class Forest{constructor(e){this._nextBranchId=1,this.trees=new Map,this.scopes=[],this.completedScopes=[],this.maxCompletedScopes=20,this.cacheInterval=e?.cacheInterval||DEFAULT_CACHE_INTERVAL}nextBranchId(){var e=this._nextBranchId;return this._nextBranchId+=1,e}addTree(e){var{name:e,data:t,upsert:r}=e;if(this.hasTree(e)){if(!r)throw new Error("cannot redefine existing treer "+e)}else this.trees.set(e,new Tree_1.Tree({forest:this,name:e,data:t}));return this.tree(e)}delete(e,t){if((0,isLeafIF_1.isLeafIF)(e))return this.delete(e.treeName,e.key);if(this.hasTree(e))return this.tree(e).del(t),{treeName:e,status:this.tree(e).status,change:{key:t,val:constants_1.DELETED,treeName:e,type:enums_1.Change_s.del}};throw new Error("cannot delete from "+e+": no tree found")}get(e,t){if(!(0,isLeafIdentityIF_1.isLeafIdentityIF)(e))return this.get({treeName:e,key:t});if(this.hasTree(e.treeName))return this.tree(e.treeName).leaf(e.key);throw new Error("forest:get -- cannot find tree "+e.treeName)}set(e,t,r){if((0,isLeafIF_1.isLeafIF)(e))return this.set(e.treeName,e.key,e.val);var s;if(this.hasTree(e))return(s=this.tree(e))?.set(t,r),{treeName:e,change:{treeName:e,key:t,val:r,type:enums_1.Change_s.set},status:s.status};throw new Error("cannot set - no tree "+e)}change(e,t){var r,s=[];for(r of e){if(!r.treeName||t)throw new Error("change: requires treeName");var i=r.treeName||t;if(!(0,isString_1.isString)(i)||!this.hasTree(i))throw new Error("change missing tree name");i=this.tree(i);s.push(i.change(r))}return s.flat()}hasKey(e,t){return this.has({treeName:e,key:t})}has(e){return!!this.hasTree(e.treeName)&&this.tree(e.treeName).has(e.key)}hasAll(e){return e.every(e=>{this.has(e)})}hasTree(e){return this.trees.has(e)}tree(e){return this.trees.get(e)}pruneScope(r){var e=this.scopes.indexOf(r);if(e<0)throw new Error("cannot find scope to prune");var t=this.scopes.slice(e);return this.scopes=this.scopes.slice(0,e),t.forEach(t=>{t.inTrees.forEach(e=>{try{this.tree(e)?.pruneScope(t.scopeID)}catch(e){console.error("error removing scope",r,e)}})}),t}get currentScope(){return this.scopes[this.scopes.length-1]}archiveScope(e){0<this.maxCompletedScopes&&(this.completedScopes.push(e),this.completedScopes.length>this.maxCompletedScopes)&&(this.completedScopes=this.completedScopes.slice(-this.maxCompletedScopes))}transact(e,t={},...r){let s=new Scope_1.default(this,t);this.scopes.push(s);let i;try{i=e(this,...r)}catch(e){s.error=e;t=this.pruneScope(s);throw s.status=enums_1.Status_s.bad,this.archiveScope(s),scopeError(s,e,t)}return s.status=enums_1.Status_s.good,this.archiveScope(s),s.inTrees.forEach(e=>{try{this.tree(e)?.endScope(s.scopeID)}catch(e){console.error("error ending scope",s,e)}}),i}}exports.Forest=Forest;