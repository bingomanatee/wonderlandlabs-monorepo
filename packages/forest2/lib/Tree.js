Object.defineProperty(exports,"__esModule",{value:!0}),exports.CLONE_NAME=void 0;let Branch_1=require("./Branch"),types_guards_1=require("./types/types.guards"),rxjs_1=require("rxjs"),utils_1=require("./utils");exports.CLONE_NAME="!CLONE!";class Tree{constructor(t,e,r){this.forest=t,this.name=e,(this.params=r)&&"initial"in r&&(t=r["initial"],void 0!==t)&&(this.root=new Branch_1.Branch(this,{assert:t,name:"initial"}),this.top=this.root),this.stream=new rxjs_1.BehaviorSubject(this.top)}get isUncacheable(){return!!this.params&&Boolean(this.params.uncacheable)}next(t,e="(next)"){this.grow({assert:t,name:e})}rollback(e,r){if(this.top&&!(this.top.time<e)){let t=this.top;for(;t.prev&&t.prev.time>=e;)t=t.prev;r={time:e,error:r,branch:t},r=(this.offshoots||(this.offshoots=[]),this.offshoots.push(r),t.prev);(this.top=r)?r.next=void 0:(this.root=void 0,this.top=void 0)}}grow(e){return this.forest.do(()=>{var t=new Branch_1.Branch(this,e);if(this.top?this.top.linkTo(t):this.root=t,this.top=t,this.params?.validator){t=this.params.validator(t.value,this);if(t)throw t}return this._maybeCache(),this._maybeTrim(),this.stream.next(this.top),this.top})}validate(r){if(!this.params?.validator)return{isValid:!0,value:r,tree:this};try{var t=this.params.validator(r,this);if(t)return{isValid:!1,value:r,tree:this,error:t.message}}catch(t){let e="";return{value:r,tree:this,isValid:!1,error:e=t instanceof Error?t.message:"string"==typeof t?t:""+t}}}_maybeCache(){if(this.top&&(0,types_guards_1.hasCachingParams)(this.params)){var{cloneInterval:r,cloner:s}=this.params;let t=this.top,e=0;for(;t;){if(e>=r){var i=s(this.top);try{var o=this.top?.add({assert:i,name:exports.CLONE_NAME});this.top=o}catch(t){console.warn("cannot clone! error is ",t)}return}if(t.cause==exports.CLONE_NAME)return;e+=1,t=t.prev}}}_maybeTrim(){if(this.top&&this.params?.cloner){var{maxBranches:t,trimTo:e}=this.params;if(.8*t<=e)throw new Error("your trim size must be 80% of your maxBranches or less");if(e<4)throw new Error("your maxBranches must be >= 4");var r,s=this.forest.activeTasks,i=this.top.time,o=this.root.time,a=i+o+1;a<t||(r=this.branchCount(t))<t||("doubler"===this.name&&console.log("_maybeTrim over length: ",{endTime:i,count:r,startTime:o,treeTime:a,maxBranches:t,activeTasks:s}),s.length?(i=s.reduce((t,e)=>Math.min(t,e),Number.POSITIVE_INFINITY),this._trim(e,i)):this._trim(e,Number.POSITIVE_INFINITY,!0))}}_trim(e,r,s=!1){let i=this.root,o=this.top;if(s||!(i.time>=r)){let t=0;for(;o&&t<e;)o=o.prev,!s&&i&&i.time&&i.time<r&&(i=i.next),t+=1;if("doubler"===this.name&&console.log("---- trimming ",t,!!o),o&&!(t<e)){if(!s)for(;i&&i.time>=r;)i=i.prev;s||o.time<r?this._trimBefore(o):this._trimBefore(i)}}}_trimBefore(t){var e,r;t&&t.prev&&t.prev!==this.root&&(e=this.root,r=t.prev.clone(!0),this.root=r,this.root.link(r,t),this._destoryOldData(e))}_destoryOldData(t){for(var e;t;)e=t.next,t.destroy(),t=e}get subject(){return this.stream.pipe((0,rxjs_1.filter)(t=>!!t),(0,rxjs_1.map)(t=>t.value))}subscribe(t){return this.subject.subscribe(t)}valueAt(e){if(this.top){let t=this.top;for(;t&&t.time>e;)t=t.prev;return t?t.value:void 0}}get value(){if(this.top)return this.top.value;throw new Error("cannot get the value from an empty tree")}addNote(t,e){this._notes||(this._notes=new Map),utils_1.NotableHelper.addNote(this.forest.time,this._notes,t,e,this.name)}hasNoteAt(t){return this._notes?.has(t)||!1}notes(t,e=0){return this._notes?utils_1.NotableHelper.notes(this._notes,t,e):[]}branchCount(t){if(!this.top)return 0;let e=0,r=this.top;for(;(!t||e<t)&&r;)e+=1,r=r.prev;return e}}exports.default=Tree;