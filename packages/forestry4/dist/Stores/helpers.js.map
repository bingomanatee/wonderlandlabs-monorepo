{"version":3,"file":"helpers.js","sources":["../../src/Stores/helpers.ts"],"sourcesContent":["import { ActionParamsRecord, ActionExposedRecord, ValueTestFn } from '../types';\nimport { Store } from './Store';\n\nexport function methodize<\n  DataType,\n  Actions extends ActionExposedRecord = ActionExposedRecord,\n>(actsMethods: ActionParamsRecord, self: Store<DataType, Actions>): Actions {\n  return Array.from(Object.keys(actsMethods)).reduce((memo, key) => {\n    const fn = actsMethods[key];\n    memo[key] = function (...args: any[]) {\n      return fn.call(self, self.value, ...args);\n    };\n    return memo as Partial<Actions>;\n  }, {}) as Actions;\n}\n\n/**\n * Utility function to preview what the exposed action signatures will look like.\n * This transforms ActionParamsRecord (with value parameter) to ActionExposedRecord (without value parameter).\n *\n * Use this during development to see what your $ and acts properties will expose:\n *\n * @example\n * const inputActions = {\n *   addItem: (cart: Cart, productId: string, quantity: number) => { ... },\n *   removeItem: (cart: Cart, productId: string) => { ... }\n * };\n *\n * // Preview what will be exposed:\n * const exposedActions = previewActionSignatures(inputActions);\n * // exposedActions.addItem: (productId: string, quantity: number) => any\n * // exposedActions.removeItem: (productId: string) => any\n *\n * @param actsMethods - The input actions with value as first parameter\n * @returns Object showing the transformed action signatures (for type inspection only)\n */\nexport function previewActionSignatures<T extends ActionParamsRecord>(\n  actsMethods: T,\n): {\n  [K in keyof T]: T[K] extends (value: any, ...args: infer Args) => infer Return\n    ? (...args: Args) => Return\n    : never;\n} {\n  const result = {} as any;\n\n  for (const key in actsMethods) {\n    const fn = actsMethods[key];\n    // Create a mock function that shows the signature without the first parameter\n    result[key] = function (..._args: any[]) {\n      // This is just for type demonstration - not meant to be called\n      throw new Error(\n        `previewActionSignatures is for type inspection only. Use store.$ or store.acts to call ${key}()`,\n      );\n    };\n\n    // Add metadata to help with debugging\n    Object.defineProperty(result[key], 'name', { value: key });\n    Object.defineProperty(result[key], 'length', {\n      value: Math.max(0, fn.length - 1),\n    });\n  }\n\n  return result;\n}\n\nexport function testize<DataType>(\n  testFunctions: ValueTestFn<DataType> | ValueTestFn<DataType>[],\n  self: Store<DataType>,\n): ValueTestFn<DataType> | ValueTestFn<DataType>[] {\n  if (Array.isArray(testFunctions)) {\n    return testFunctions.map(\n      (fn) =>\n        function (value: unknown) {\n          return fn.call(self, value, self);\n        },\n    );\n  } else {\n    return function (value: unknown) {\n      return testFunctions.call(self, value, self);\n    };\n  }\n}\n"],"names":[],"mappings":"AAGO,SAAS,UAGd,aAAiC,MAAyC;AAC1E,SAAO,MAAM,KAAK,OAAO,KAAK,WAAW,CAAC,EAAE,OAAO,CAAC,MAAM,QAAQ;AAChE,UAAM,KAAK,YAAY,GAAG;AAC1B,SAAK,GAAG,IAAI,YAAa,MAAa;AACpC,aAAO,GAAG,KAAK,MAAM,KAAK,OAAO,GAAG,IAAI;AAAA,IAC1C;AACA,WAAO;AAAA,EACT,GAAG,CAAA,CAAE;AACP;AAmDO,SAAS,QACd,eACA,MACiD;AACjD,MAAI,MAAM,QAAQ,aAAa,GAAG;AAChC,WAAO,cAAc;AAAA,MACnB,CAAC,OACC,SAAU,OAAgB;AACxB,eAAO,GAAG,KAAK,MAAM,OAAO,IAAI;AAAA,MAClC;AAAA,IAAA;AAAA,EAEN,OAAO;AACL,WAAO,SAAU,OAAgB;AAC/B,aAAO,cAAc,KAAK,MAAM,OAAO,IAAI;AAAA,IAC7C;AAAA,EACF;AACF;"}