{"version":3,"file":"path.js","sources":["../../src/lib/path.ts"],"sourcesContent":["import { Path } from '../types';\nimport { type, TypeEnum } from '@wonderlandlabs/walrus';\n\n/**\n * Helper function to get nested values from complex structures.\n * Uses Walrus type methods to identify the variation of each node.\n * Supports objects, arrays, Maps, and other complex structures.\n */\nexport function getPath(source: any, pathArray: Path): unknown {\n  if (!Array.isArray(pathArray)) {\n    return getPath(source, pathArray.split('.'));\n  }\n  // Navigate through all path elements using reduce\n  const result = pathArray.reduce((current, pathSegment) => {\n    if (current === undefined || current === null) {\n      return undefined;\n    }\n\n    const currentType = type.describe(current, true);\n\n    switch (currentType) {\n      case TypeEnum.map:\n        return current.get(pathSegment);\n\n      case TypeEnum.array: {\n        if (typeof pathSegment === 'number') {\n          return current[pathSegment];\n        }\n        const index = parseInt(pathSegment, 10);\n        if (isNaN(index)) {\n          return undefined;\n        }\n        return current[index];\n      }\n      case TypeEnum.object:\n        return current[pathSegment];\n\n      default:\n        return undefined;\n    }\n  }, source);\n\n  return result;\n}\n\n/**\n * Helper function to set nested values in Immer drafts.\n * Uses Walrus type methods to identify the variation of each node.\n * Supports objects, arrays, Maps, and other complex structures.\n */\nexport function setPath(draft: any, pathArray: Path, value: unknown): void {\n  // Navigate through all but the last element using reduce\n  if (!Array.isArray(pathArray)) {\n    return setPath(draft, pathArray.split('.'), value);\n  }\n  const [target] = pathArray.slice(0, pathArray.length - 1).reduce(\n    ([current], pathSegment) => {\n      const currentType = type.describe(current, true);\n\n      switch (currentType) {\n        case TypeEnum.map:\n          if (!current.has(pathSegment)) {\n            current.set(pathSegment, {});\n          }\n          return [current.get(pathSegment)];\n\n        case TypeEnum.array: {\n          if (typeof pathSegment === 'number') {\n            return current[pathSegment];\n          }\n          const index = parseInt(pathSegment, 10);\n          if (isNaN(index)) {\n            throw new Error(`Invalid array index: ${pathSegment}`);\n          }\n          if (current[index] === undefined) {\n            current[index] = {};\n          }\n          return [current[index]];\n        }\n        case TypeEnum.object:\n          if (\n            current[pathSegment] === undefined ||\n            current[pathSegment] === null\n          ) {\n            current[pathSegment] = {};\n          }\n          return [current[pathSegment]];\n\n        default:\n          throw new Error(`Cannot set nested value on type: ${currentType}`);\n      }\n    },\n    [draft],\n  );\n\n  // Final assignment based on target type\n  const finalKey = pathArray[pathArray.length - 1];\n  const finalType = type.describe(target, true);\n\n  switch (finalType) {\n    case TypeEnum.map:\n      target.set(finalKey, value);\n      break;\n\n    case TypeEnum.array:\n      if (typeof finalKey === 'number') {\n        target[finalKey] = value;\n      } else {\n        const index = parseInt(finalKey, 10);\n        if (isNaN(index)) {\n          throw new Error(`Invalid array index: ${finalKey}`);\n        }\n        target[index] = value;\n      }\n      break;\n\n    case TypeEnum.object:\n      target[finalKey] = value;\n      break;\n\n    default:\n      throw new Error(`Cannot set value on type: ${finalType}`);\n  }\n}\n"],"names":[],"mappings":"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"}