Object.defineProperty(exports,"__esModule",{value:!0}),exports.Tree=void 0;let enums_1=require("./helpers/enums"),BranchMap_1=require("./BranchMap"),Leaf_1=require("./Leaf"),isChangeSet_1=require("./helpers/isChangeSet"),isTreeDel_1=require("./helpers/isTreeDel"),constants_1=require("./constants"),BranchObj_1=require("./BranchObj");class Tree{constructor(e){this.activeScopeCauseIDs=new Set;var{forest:t,name:r,data:a}=e;this.forest=t,this.name=r,this.dataType=e.dataType||enums_1.DataType_s.map,a&&(this.root=this.makeBranch({data:e.data,cause:enums_1.Action_s.init}))}makeBranch(e){let t;if(this.dataType===enums_1.DataType_s.map){if(e.data&&!(e.data instanceof Map))throw new Error("bad data param(map)");t=new BranchMap_1.BranchMap(this,e)}else{if(this.dataType!==enums_1.DataType_s.object)throw new Error("cannot type tree "+this.name);if(e.data&&"object"!=typeof e.data)throw new Error("bad data param(obj)");t=new BranchObj_1.BranchObj(this,e)}return t}endScope(e){let t=this.top;for(;t;){if(t.causeID===e){t.pop();break}t=t.next}this.activeScopeCauseIDs.delete(e)}pruneScope(e){let t=this.root;for(;t;){if(t.causeID===e){t.prune();break}t=t.next}this.activeScopeCauseIDs.delete(e)}get size(){let r=new Set,e=this.root;for(;e;)e.forEach((e,t)=>r.add(t)),e=e.next;return r.size}values(){switch(this.dataType){case enums_1.DataType_s.map:return this.root?this.root.values():new Map;case enums_1.DataType_s.object:return this.root?this.root.values():{};default:throw new Error("cannot manage type")}}clearValues(){var e;return this.root?this.forest.currentScope?(e=new BranchMap_1.BranchMap(this,{cause:enums_1.Action_s.clear}),(this.top.next=e).cache=new Map,[]):(e=this.branches,this.root=void 0,e):[]}get branches(){var e=[];let t=this.root;for(;t;)e.push(t),t=t.next;return e}get top(){if(this.root){let e=this.root;for(;e&&e.next;)e=e.next;return e}}leaf(e){return this.root?this.root.leaf(e):new Leaf_1.Leaf({treeName:this.name,key:e,val:constants_1.NOT_FOUND})}get(e){if(this.root)return this.top?.get(e)}has(e){return!!this.root&&!!this.top?.has(e)}maybeCache(){var e=this.top;e&&(this.count(this.forest.cacheInterval)>=this.forest.cacheInterval&&(e.cache=e.mergeData()),e.prev?.clearCache())}count(e=-1){let t=0,r=this.top;for(;r&&(t+=1,r=r.prev,!(0<=e&&t>=e)););return t}pushCurrentScope(){var e;this.forest.currentScope&&!this.forest.currentScope.inTrees.has(this.name)&&(this.forest.currentScope?.inTrees.add(this.name),e=new BranchMap_1.BranchMap(this,{cause:enums_1.Action_s.trans,causeID:this.forest.currentScope.scopeID}),this.top?(0,BranchMap_1.linkBranches)(this.top,e):this.root=e)}set(e,t){if(this.forest.currentScope&&this.pushCurrentScope(),this.root)this.top?.set(e,t);else switch(this.dataType){case enums_1.DataType_s.map:this.root=new BranchMap_1.BranchMap(this,{data:new Map([[e,t]]),cause:enums_1.Action_s.set});break;case enums_1.DataType_s.object:throw new Error("not implemented");default:throw new Error("bad dataType")}}del(e){if(this.root&&this.top?.has(e))return this.forest.currentScope&&this.pushCurrentScope(),this.top?.del(e)}get status(){return enums_1.Status_s.good}change(e){if((0,isChangeSet_1.isTreeSet)(e))this.set(e.key,e.val);else{if(!(0,isTreeDel_1.isTreeDel)(e))throw new Error("not implemented");this.del(e.key)}return{treeName:this.name,change:e,status:this.status}}}exports.Tree=Tree;