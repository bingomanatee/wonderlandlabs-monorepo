{"version":3,"file":"Store.js","sources":["../../src/Stores/Store.ts"],"sourcesContent":["import {\n  ActionExposedRecord,\n  Listener,\n  Path,\n  PendingValue,\n  StoreIF,\n  StoreParams,\n  TransFn,\n  TransParams,\n  ValueTestFn,\n} from '../types';\nimport { BehaviorSubject, Observable, Subject, Subscription } from 'rxjs';\nimport { distinctUntilChanged } from 'rxjs/operators';\nimport { isEqual } from 'lodash-es';\nimport asError from '../lib/asError';\nimport { isZodParser, ZodParser } from '../typeguards';\nimport { enableMapSet, produce } from 'immer';\nimport { methodize, testize } from './helpers';\nimport { getPath, setPath } from '../lib/path';\nimport { pathString } from '../lib/combinePaths';\n\n// Enable Immer support for Map and Set\nenableMapSet();\n\nexport class Store<\n  DataType,\n  Actions extends ActionExposedRecord = ActionExposedRecord,\n> implements StoreIF<DataType, Actions>\n{\n  /**\n   * note - for consistency with the types subject is a generic subject;\n   * however internally it is a BehaviorSubject.\n   * @private\n   */\n  #subject?: BehaviorSubject<DataType>;\n  get subject(): Observable<DataType> {\n    return this.#subject!;\n  }\n\n  $: Actions;\n\n  get acts(): Actions {\n    return this.$;\n  }\n\n  constructor(p: StoreParams<DataType, Actions>, noSubject = false) {\n    // Apply prep function to initial value if it exists\n    if (!noSubject) {\n      this.#subject = new BehaviorSubject(p.value);\n    }\n\n    if ('schema' in p && p.schema) {\n      this.schema = p.schema;\n    }\n\n    this.debug = !!p.debug;\n\n    const self = this;\n    this.$ = methodize<DataType, Actions>(p.actions ?? {}, self);\n\n    if (p.tests) {\n      this.tests = testize<DataType>(p.tests, self);\n    }\n    if (p.prep) {\n      this.#prep = p.prep.bind(this);\n      if (this.#subject) {\n        this.#subject.next(this.prep!(this.value!, this.value!));\n      }\n    }\n\n    if (p.name && typeof p.name === 'string') {\n      this.#name = p.name;\n    }\n    if (p.res && p.res instanceof Map) {\n      p.res.forEach((value, key) => this.res.set(key, value));\n    }\n  }\n\n  public debug: boolean; // more alerts on validation failures;\n  #prep?: (input: Partial<DataType>, current: DataType) => DataType;\n  // @ts-expect-error TS2416 -- value is not a complete DataType\n  prep(value: Partial<DataType>) {\n    if (this.#prep) {\n      return this.#prep.call(this, value, this.value);\n    }\n    return value;\n  }\n  public res: Map<string, any> = new Map();\n\n  #name?: string;\n  get name(): string {\n    if (!this.#name) {\n      this.#name = 'forestry-store:' + `${Math.random()}`.split('.').pop();\n    }\n    return this.#name!;\n  }\n\n  complete(): DataType {\n    if (!this.isActive) {\n      return this.value!;\n    }\n\n    const finalValue = this.value;\n    this.isActive = false;\n\n    // Complete the RxJS subject\n    if (this.#subject) {\n      this.#subject.complete();\n    }\n\n    return finalValue;\n  }\n\n  isActive: boolean = true;\n\n  next(value: Partial<DataType>): void {\n    if (!this.isActive) {\n      throw new Error('Cannot update completed store');\n    }\n\n    // Apply prep function if it exists to transform partial input to complete data\n    const preparedValue = this.prep\n      ? this.prep(value, this.value!)\n      : (value as DataType);\n\n    const { isValid, error } = this.validate(preparedValue);\n    if (!this.subject) {\n      throw new Error('Store requires subject -- or override of next()');\n    }\n    if (isValid) {\n      if (this.#hasTrans()) {\n        this.queuePendingValue(preparedValue);\n      } else {\n        this.#subject!.next(preparedValue);\n      }\n      return;\n    }\n    if (this.debug) {\n      console.error(\n        'cannot update ',\n        this.name,\n        'with',\n        value,\n        '(current: ',\n        this.value,\n        ')',\n        error,\n      );\n    }\n    throw asError(error);\n  }\n\n  #test(fn: ValueTestFn<DataType>, value: unknown) {\n    const result = fn.call(this, value, this);\n    if (result) {\n      throw asError(result);\n    }\n    // no result/output for valid elements\n  }\n\n  public get suspendValidation() {\n    return this.#transStack.value.some((p) => p.suspendValidation);\n  }\n\n  transact(params: TransParams | TransFn, suspend?: boolean) {\n    if (typeof params === 'function') {\n      this.transact({\n        action: params,\n        suspendValidation: !!suspend,\n      });\n      return;\n    }\n    const { action, suspendValidation } = params;\n    let transId: string = '';\n    try {\n      transId = this.#queuePendingTrans(suspendValidation);\n      const self = this;\n      function boundFn(value: DataType) {\n        return action.call(self, value);\n      }\n\n      boundFn(this.value!);\n      this.#commitTransact(transId);\n    } catch (err) {\n      if (transId) {\n        this.#revertTransact(transId);\n      }\n      throw err;\n    }\n  }\n\n  readonly #transStack: BehaviorSubject<PendingValue<DataType>[]> =\n    new BehaviorSubject<PendingValue<DataType>[]>([]);\n\n  // for debugging\n  observeTransStack(listener: Listener<PendingValue<DataType>[]>) {\n    return this.#transStack.subscribe(listener);\n  }\n\n  #commitTransact(id: string) {\n    let changed = false;\n    const nextStack = this.#transStack.value.map((p) => {\n      if (p.id === id) {\n        changed = true;\n        return {\n          ...p,\n          isTransaction: false,\n          suspendValidation: false,\n        };\n      } else {\n        return p;\n      }\n    });\n    if (changed) {\n      this.#transStack.next(nextStack);\n    }\n    this.#checkTransComplete();\n  }\n\n  #checkTransComplete() {\n    if (!this.#transStack.value.some((p) => p.isTransaction)) {\n      const last = this.#transStack.value.pop();\n      this.#transStack.next([]);\n      if (last) {\n        this.broadcast({\n          action: 'checkTransComplete',\n          phase: 'next',\n          value: last.value,\n        });\n        this.next(last.value);\n      }\n    }\n  }\n\n  queuePendingValue(value: DataType): string {\n    const digits = `${Math.random()}`.replace('0.', '');\n    const id = `level_${this.#transStack.value.length}-${digits}-trans`;\n\n    const next = [\n      ...this.#transStack.value,\n      {\n        id,\n        value,\n        isTransaction: false,\n      },\n    ];\n    this.#transStack.next(next);\n    return id;\n  }\n\n  #hasTrans() {\n    return this.#transStack.value.some((p) => p.isTransaction);\n  }\n\n  #collapseTransStack = () => {\n    if (this.#hasTrans()) {\n      return;\n    }\n\n    const last = this.#transStack.value.pop();\n    this.#transStack.next([]);\n    return last;\n  };\n\n  dequeuePendingValue(id: string): PendingValue<DataType> | undefined {\n    const queuedIndex = this.#transStack.value.findIndex((p) => p.id === id);\n    if (queuedIndex === this.#transStack.value.length - 1) {\n      if (!this.#transStack.value.some((p) => p.isTransaction)) {\n        return this.#collapseTransStack();\n      }\n    }\n  }\n\n  #queuePendingTrans(suspendValidation = false): string {\n    const digits = `${Math.random()}`.replace('0.', '');\n    const id = `level_${this.#transStack.value.length}-${digits}-trans`;\n    const next = [\n      ...this.#transStack.value,\n      {\n        id,\n        value: this.value,\n        suspendValidation,\n        isTransaction: true,\n      },\n    ];\n    this.#transStack.next(next);\n    return id;\n  }\n\n  #revertTransact(id: string) {\n    const index = this.#transStack.value.findIndex((p) => p.id === id);\n    if (index >= 0) {\n      const next = this.#transStack.value.slice(0, index);\n      this.#transStack.next(next);\n    }\n  }\n\n  get root() {\n    return this;\n  }\n\n  get isRoot() {\n    return true;\n  }\n\n  parent: undefined;\n\n  public broadcast(message: unknown, fromRoot?: boolean) {\n    if (fromRoot || !this.parent) {\n      this.receiver.next(message);\n    }\n    if (this.root && this.root !== this) {\n      this.root.broadcast(message);\n    }\n  }\n\n  public receiver = new Subject();\n\n  validate(value: unknown) {\n    if (this.suspendValidation) {\n      return { isValid: true };\n    }\n    try {\n      if (isZodParser(this.schema)) {\n        this.schema.parse(value); // throws an error if the value is not valid\n      }\n      if (this.tests) {\n        if (Array.isArray(this.tests)) {\n          for (const test of this.tests) {\n            this.#test(test, value);\n          }\n        } else if (typeof this.tests === 'function') {\n          this.#test(this.tests, value);\n        }\n      }\n      return {\n        isValid: true,\n      };\n    } catch (e) {\n      return {\n        isValid: false,\n        error: asError(e),\n      };\n    }\n  }\n\n  isValid(value: unknown): boolean {\n    return this.validate(value).isValid;\n  }\n\n  schema?: ZodParser;\n\n  tests?: ValueTestFn<DataType> | ValueTestFn<DataType>[];\n\n  get value() {\n    const tsv = this.#transStack.value;\n    if (tsv.length) {\n      return tsv[tsv.length - 1].value;\n    }\n    if (!this.#subject) {\n      throw new Error('Store requires subject or overload of value');\n    }\n    return this.#subject.value as DataType;\n  }\n\n  subscribe(listener: Listener<DataType>): Subscription {\n    return this.subject!.pipe(distinctUntilChanged(isEqual)).subscribe(\n      listener,\n    );\n  }\n\n  get(path?: Path): any {\n    if (!path || (Array.isArray(path) && path.length === 0)) {\n      return this.value;\n    }\n    const pathArray = Array.isArray(path) ? path : pathString(path).split('.');\n    return getPath(this.value, pathArray);\n  }\n\n  set(path: Path, value: unknown) {\n    const next = produce(this.value, (draft) => {\n      setPath(draft, path, value);\n    });\n    this.next(next);\n  }\n\n  mutate(producerFn: (draft: any) => void, path?: Path): any {\n    if (!path || (Array.isArray(path) && path.length === 0)) {\n      // Mutate the entire state\n      const newValue = produce(this.value, producerFn);\n      this.next(newValue);\n      return this.value;\n    } else {\n      // Mutate a specific path within the state\n      const pathArray = Array.isArray(path)\n        ? path\n        : pathString(path).split('.');\n      const newValue = produce(this.value, (draft) => {\n        // Get the target object at the specified path\n        const target = getPath(draft, pathArray);\n        if (target !== undefined) {\n          // Apply the producer function to the target\n          producerFn(target);\n        }\n      });\n      this.next(newValue);\n      return this.value;\n    }\n  }\n}\n"],"names":[],"mappings":"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"}