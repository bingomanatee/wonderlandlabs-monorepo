Object.defineProperty(exports,"__esModule",{value:!0}),exports.Forest=void 0;let isString_1=require("./helpers/isString"),isLeafIdentityIF_1=require("./helpers/isLeafIdentityIF"),Tree_1=require("./Tree"),isLeafIF_1=require("./helpers/isLeafIF"),constants_1=require("./constants"),enums_1=require("./enums");class Forest{constructor(){this.trees=new Map}delete(e,r){if((0,isLeafIF_1.isLeafIF)(e))return this.delete(e.treeName,e.key);if(this.hasTree(e))return this.tree(e).del(r),{treeName:e,status:this.tree(e).status,change:{key:r,val:constants_1.DELETED,treeName:e,type:enums_1.ChangeTypeEnum.del}};throw new Error("cannot delete from "+e+": no tree found")}addTree(e){var{name:e,data:r,upsert:t}=e;if(this.hasTree(e)){if(!t)throw new Error("cannot redefine existing treer "+e)}else this.trees.set(e,new Tree_1.Tree({forest:this,treeName:e,data:r}));return this.tree(e)}get(e,r){if(!(0,isLeafIdentityIF_1.isLeafIdentityIF)(e))return this.get({treeName:e,key:r});if(this.hasTree(e.treeName))return this.tree(e.treeName).leaf(e.key);throw new Error("forest:get -- cannot find tree "+e.treeName)}set(e,r,t){if((0,isLeafIF_1.isLeafIF)(e))return this.set(e.treeName,e.key,e.val);var s;if(this.hasTree(e))return(s=this.tree(e))?.set(r,t),{treeName:e,change:{treeName:e,key:r,val:t,type:enums_1.ChangeTypeEnum.set},status:s.status};throw new Error("cannot set - no tree "+e)}change(e,r){var t,s=[];for(t of e){if(!t.treeName||r)throw new Error("change: requires treeName");var a=t.treeName||r;if(!(0,isString_1.isString)(a)||!this.hasTree(a))throw new Error("change missing tree name");a=this.tree(a);s.push(a.change(t))}return s.flat()}hasKey(e,r){return this.has({treeName:e,key:r})}has(e){return!!this.hasTree(e.treeName)&&this.tree(e.treeName).has(e.key)}hasAll(e){return e.every(e=>{this.has(e)})}hasTree(e){return this.trees.has(e)}tree(e){return this.trees.get(e)}}exports.Forest=Forest;